package zkverifier_kit

import (
	"errors"
	"fmt"
	"maps"
	"os"
	"strconv"
	"time"

	val "github.com/go-ozzo/ozzo-validation/v4"
	zkptypes "github.com/iden3/go-rapidsnark/types"
	zkpverifier "github.com/iden3/go-rapidsnark/verifier"
	"github.com/rarimo/zkverifier-kit/identity"
)

type PubSignal int

// predefined values and positions for public inputs in zero knowledge proof. It
// may change depending on the proof and the values that it reveals.
const (
	Nullifier                 PubSignal = 0
	BirthDate                 PubSignal = 1
	ExpirationDate            PubSignal = 2
	Citizenship               PubSignal = 6
	EventID                   PubSignal = 9
	EventData                 PubSignal = 10
	IdStateRoot               PubSignal = 11
	Selector                  PubSignal = 12
	TimestampUpperBound       PubSignal = 14
	IdentityCounterUpperBound PubSignal = 16
	BirthdateUpperBound       PubSignal = 18
	ExpirationDateLowerBound  PubSignal = 19
)

var ErrVerificationKeyRequired = errors.New("verification key is required")

// Verifier is a structure representing some instance for validation and verification zero knowledge proof
// generated by Rarimo system.
type Verifier struct {
	// verificationKey stores verification key content
	verificationKey []byte
	// opts has fields that must be validated before proof verification.
	opts VerifyOptions
}

// NewPassportVerifier creates a new Verifier instance. VerificationKey is
// required to VerifyGroth16, usually you should just read it from file. Optional
// parameters will take part in proof verification on Verifier.VerifyProof call.
//
// If you provided WithVerificationKeyFile option, you can pass nil as the first arg.
func NewPassportVerifier(verificationKey []byte, options ...VerifyOption) (*Verifier, error) {
	verifier := Verifier{
		verificationKey: verificationKey,
		opts:            mergeOptions(true, VerifyOptions{}, options...),
	}

	file := verifier.opts.verificationKeyFile
	if file == "" {
		if len(verificationKey) == 0 {
			return nil, ErrVerificationKeyRequired
		}
		return &verifier, nil
	}

	var err error
	verifier.verificationKey, err = os.ReadFile(file)
	if err != nil {
		return nil, fmt.Errorf("failed to read verification key from file %q: %w", file, err)
	}

	return &verifier, nil
}

// VerifyProof method verifies iden3 ZK proof and checks public signals. The
// public signals to validate are defined in the VerifyOption list. Firstly, you
// pass initial values to verify in NewPassportVerifier. In case when custom
// values are required for different proofs, the options can be passed to
// VerifyProof, which override the initial ones.
func (v *Verifier) VerifyProof(proof zkptypes.ZKProof, options ...VerifyOption) error {
	v2 := Verifier{
		verificationKey: v.verificationKey,
		opts:            mergeOptions(false, v.opts, options...),
	}

	if err := v2.validateBase(proof); err != nil {
		return err
	}

	if err := zkpverifier.VerifyGroth16(proof, v.verificationKey); err != nil {
		return val.Errors{
			"/proof": fmt.Errorf("groth16 verification failed: %w", err),
		}
	}

	return nil
}

func (v *Verifier) validateBase(zkProof zkptypes.ZKProof) error {
	signals := zkProof.PubSignals

	err := val.Errors{
		"zk_proof/proof":       val.Validate(zkProof.Proof, val.Required),
		"zk_proof/pub_signals": val.Validate(signals, val.Required, val.Length(22, 22)),
	}.Filter()
	if err != nil {
		return err
	}

	err = v.opts.rootVerifier.VerifyRoot(signals[IdStateRoot])
	if errors.Is(err, identity.ErrContractCall) {
		return err
	}

	all := val.Errors{
		"pub_signals/nullifier":     val.Validate(signals[Nullifier], val.Required),
		"pub_signals/selector":      val.Validate(signals[Selector], val.Required, val.In(v.opts.proofSelectorValue)),
		"pub_signals/id_state_root": err,
		"pub_signals/event_id":      validateOnOptSet(signals[EventID], v.opts.eventID, val.In(v.opts.eventID)),
		// upper bound is a date: the earlier it is, the higher the age
		"pub_signals/citizenship": validateOnOptSet(decodeInt(signals[Citizenship]), v.opts.citizenships, val.In(v.opts.citizenships...)),
		"pub_signals/event_data":  validateOnOptSet(signals[EventData], v.opts.eventDataRule, v.opts.eventDataRule),
	}

	maps.Copy(all, v.validateBirthDate(signals))
	maps.Copy(all, v.validatePassportExpiration(signals))
	maps.Copy(all, v.validateIdentitiesInputs(signals))

	return all.Filter()
}

func (v *Verifier) validateBirthDate(signals []string) val.Errors {
	if v.opts.age == -1 {
		return nil
	}

	allowedBirthDate := time.Now().UTC().AddDate(-v.opts.age, 0, 0)
	return ORError(
		val.Validate(signals[BirthDate], val.Required, beforeDate(allowedBirthDate)),
		val.Validate(signals[BirthdateUpperBound], val.Required, equalDate(allowedBirthDate)),
		[2]string{"pub_signals/birth_date", "pub_signals/birth_date_upper_bound"},
	)
}

func (v *Verifier) validatePassportExpiration(signals []string) val.Errors {
	return val.Errors{
		"pub_signals/expiration_date_lower_bound": val.Validate(
			signals[ExpirationDateLowerBound],
			val.When(!isEmptyZKDate(signals[ExpirationDateLowerBound]), equalDate(time.Now().UTC())),
		),
		"pub_signals/expiration_date": val.Validate(
			signals[ExpirationDate],
			val.When(!isEmptyZKDate(signals[ExpirationDate]), afterDate(time.Now().UTC())),
		),
	}
}

// ZKP sets dates to 0 or 52983525027888 if date is not used or is not present in selector
func isEmptyZKDate(dateStr string) bool {
	return dateStr == "0" || dateStr == "52983525027888"
}

func (v *Verifier) validateIdentitiesInputs(signals []string) val.Errors {
	counter, err := strconv.ParseInt(signals[IdentityCounterUpperBound], 10, 64)
	if err != nil {
		return val.Errors{"pub_signals/identity_counter_upper_bound": err}
	}

	// ZKP generates a timestamp upper bound as regular unix timestamp, so or time validation is not suitable here
	timestamp, err := strconv.ParseInt(signals[TimestampUpperBound], 10, 64)
	if err != nil {
		return val.Errors{"pub_signals/timestamp_upper_bound": err}
	}

	return ORError(
		val.Validate(counter, val.When(
			v.opts.maxIdentitiesCount != -1,
			val.Required,
			val.Max(v.opts.maxIdentitiesCount),
		)),
		validateOnOptSet(
			time.Unix(timestamp, 0),
			v.opts.maxIdentityCreationTimestamp,
			val.Max(v.opts.maxIdentityCreationTimestamp),
		),
		[2]string{"pub_signals/identity_counter_upper_bound", "pub_signals/timestamp_upper_bound"},
	)
}

func ORError(one, another error, fieldNames [2]string) val.Errors {
	// OR logic: at least one of the signals should be valid
	switch {
	case one != nil:
		return val.Errors{fieldNames[1]: another}
	case another != nil:
		return val.Errors{fieldNames[0]: one}
	default:
		return nil
	}
}
